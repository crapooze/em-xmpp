$LOAD_PATH.unshift './lib'
require 'em-xmpp'
require 'em-xmpp/helpers'
require 'em-xmpp/conversation'

if ARGV.empty?
  puts "usage: #{__FILE__} <jid> <pass|passfile> <cmd>"
  exit 0 
end

jid     = ARGV.first
pass    = if File.file? ARGV[1]
            File.read ARGV[1]
          else
            ARGV[1]
          end

class CommandParseError < ArgumentError
end

module Command extend self

  def parse_formdata(allfields)
    allfields.split('&').map do |onefield|
      var,type,*values = onefield.split(',')
      EM::Xmpp::Context::Contexts::Dataforms::Field.new(var,type,nil,values)
    end
  end

  def print_dataform(ctx)
    df = ctx.bit!(:dataforms)
    df.x_forms.each do |form|
      form.fields.each_with_index do |field,fidx|
        puts "#{fidx}) #{field.label || '_'} (#{field.var}/#{field.type})"
        letter = 'a'
        field.options.each do |opt| 
          puts "#{fidx}.#{letter}) #{opt.value} -- #{opt.label || '_'}"
          letter = letter.succ
        end
        puts "Currently:"
        field.values.each do |val| 
          puts "#{val}"
          letter = letter.succ
        end
      end
    end
  end


  def for(str)
    cmd,param = str.split(':',2)
    case cmd

    when 'quit'
      lambda do |client|
        client.quit
      end

    when 'set'
      key,val = param.split(':', 2)
      lambda do |client|
        client.set(key,val)
      end

    when 'roster','list-roster','show-roster'
      lambda do |client|
        roster = client.get_roster
        puts "Buddy list:"
        groups = roster.map(&:groups).flatten.uniq
        puts "==== No Group ==="
        items = roster.select{|i| i.groups.empty?}
        items.each do |item|
          puts "#{item.name||item.jid} -- #{item.jid} (#{item.type})"
        end

        groups.each do |group|
          puts "==== #{group} === "
          items = roster.select{|i| i.groups.include?(group)}
          items.each do |item|
            puts "#{item.jid} -- #{item.name} (#{item.type})"
          end
        end
      end

    when 'unsubscribe', 'unsubscribe-from'
      lambda do |client|
        puts "unsubscribing from: #{param}"
        client.entity(param).unsubscribe
        client.entity(param).remove_from_roster
      end

    when 'subscribe', 'subscribe-to'
      lambda do |client|
        puts "subscribing to: #{param}"
        client.entity(param).subscribe
        client.entity(param).add_to_roster
      end

    when 'subscribed', 'accept-subscription'
      lambda do |client|
        puts "accept subscription from: #{param}"
        client.entity(param).accept_subscription
      end

      ### PUBSUB
      ###### Service user

    when 'pubsub-service-subscriptions'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "=== PubSub Subscriptions on #{jid} (#{node}) ==="
        ctx = client.entity(jid).pubsub(node).service_subscriptions
        ctx.bit!(:pubsub).subscriptions.each do |s|
          puts "#{s.node} -- #{s.subscription} (#{s.sub_id})"
        end
      end
    when 'pubsub-service-affiliations'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "=== PubSub Affiliations on #{jid} (#{node}) ==="
        ctx = client.entity(jid).pubsub(node).service_affiliations
        ctx.bit!(:pubsub).affiliations.each do |s|
          puts "#{s.node} (#{s.affiliation})"
        end
      end
    when 'psubscribe','pubsub-subscribe'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "subscribing to PubSub: #{jid} (#{node})"
        client.entity(jid).pubsub(node).subscribe
      end
    when 'punsubscribe','pubsub-unsubscribe'
      jid,node,subid = param.split(':',3)
      lambda do |client|
        puts "unsubscribing from PubSub: #{jid} (#{node}:#{subid})"
        client.entity(jid).pubsub(node).unsubscribe(subid)
      end
    when 'subscription-options'
      jid,node,subid = param.split(':',3)
      lambda do |client|
        puts "listing options of subscription on: #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).subscription_options(subid)
        puts "=== PubSub subscription options form ==="
        Command.print_dataform ctx
      end
    when 'pubsub-subscription-default-options'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "listing default subscription options of: #{jid} (#{node})"
        entity = client.entity(jid).pubsub
        entity = entity.node(node) if node
        ctx = entity.default_subscription_configuration
        puts "=== PubSub default subscription options ==="
        Command.print_dataform ctx
      end
    when 'pubsub-configure-subscription'
      jid,node,formdata = param.split(':',3)
      lambda do |client|
        fields = Command.parse_formdata formdata
        form = EM::Xmpp::Context::Contexts::Dataforms::Form.new('submit', fields)
        puts "configuring #{fields.size} fields of subscription: #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).configure_subscription(form)
      end
    when 'pubsub-items'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "request items from PubSub: #{jid} (#{node})"
        client.entity(jid).pubsub(node).items
      end

      ###### Node owner

    when 'publish'
      jid,node,payload = param.split(':',3)
      payload ||= "empty-payload"
      lambda do |client|
        puts "publishing #{payload.size} bytes to #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).publish(payload)
        ctx.bit!(:pubsub).items.each do |item|
          puts "published: #{item.item_id} at #{item.node}"
        end
      end
    when 'retract'
      jid,node,item_id = param.split(':',3)
      lambda do |client|
        puts "retracting #{item_id} from #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).retract(item_id)
      end
    when 'create'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "creating PubSub node: #{jid} (#{node})"
        client.entity(jid).pubsub(node).create
      end
    when 'purge'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "purging PubSub node: #{jid} (#{node})"
        client.entity(jid).pubsub(node).purge
      end
    when 'delete'
      jid,node,uri = param.split(':',3)
      lambda do |client|
        puts "delete PubSub node: #{jid} (#{node})"
        client.entity(jid).pubsub(node).delete(uri)
      end
    when 'pubsub-node-subscriptions'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "=== PubSub Subscriptions on #{jid} ==="
        ctx = client.entity(jid).pubsub(node).subscriptions
        ctx.bit!(:pubsubowner).subscriptions.each do |s|
          puts "#{s.jid} -- #{s.subscription} (#{s.sub_id})"
        end
      end
    when 'pubsub-node-affiliations'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "=== PubSub Affiliations on #{jid} ==="
        ctx = client.entity(jid).pubsub(node).affiliations
        ctx.bit!(:pubsubowner).affiliations.each do |s|
          puts "#{s.jid} (#{s.affiliation})"
        end
      end

    when 'pubsub-node-options'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "listing PubSub node configuration options: #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).configuration_options
        puts "=== PubSub node configuration options form ==="
        Command.print_dataform ctx
      end

    when 'pubsub-node-default-options'
      jid,node = param.split(':',2)
      lambda do |client|
        puts "listing default PubSub node configuration options: #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).default_configuration
        puts "=== PubSub default node configuration options form ==="
        Command.print_dataform ctx
      end

    when 'pubsub-configure-node'
      jid,node,formdata = param.split(':',3)
      lambda do |client|
        fields = Command.parse_formdata formdata
        form = EM::Xmpp::Context::Contexts::Dataforms::Form.new('submit', fields)
        puts "configuring #{fields.size} fields of node: #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).configure(form)
      end

    when 'pubsub-node-change-affiliation'
      jid,node,affilee,aff = param.split(':',4)
      lambda do |client|
        puts "changing affiliation of #{affilee} to #{aff} on #{jid} (#{node})"
        affiliation = EM::Xmpp::Context::Contexts::PubsubMain::Affiliation.new(affilee,node,aff)
        ctx = client.entity(jid).pubsub(node).modify_affiliations([affiliation])
      end

    when 'pubsub-node-change-subscription'
      jid,node,subscribee,sub_type,subid = param.split(':',5)
      lambda do |client|
        puts "changing subscription of #{subscribee} (#{subid}) to #{sub_type} on #{jid} (#{node})"
        subscription = EM::Xmpp::Context::Contexts::PubsubMain::Subscription.new(subscribee,node,sub_type,subid)
        ctx = client.entity(jid).pubsub(node).modify_subscriptions([subscription])
      end

    when 'pubsub-node-delete-affiliation'
      jid,node,affilee = param.split(':',3)
      lambda do |client|
        puts "removing affiliation of #{affilee} on #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).delete_affiliations(affilee)
      end

    when 'pubsub-node-delete-subscription'
      jid,node,subscribee,subid = param.split(':',4)
      lambda do |client|
        puts "deleting subscription of #{subscribee} (#{subid}) on #{jid} (#{node})"
        ctx = client.entity(jid).pubsub(node).delete_subscriptions(subscribee,subid)
      end

      ### MUC

    when 'join-muc'
      muc,nick = param.split(':',2)
      lambda do |client|
        puts "joining MUC: #{muc} as #{nick}"
        client.entity(muc).muc.join(nick)
      end

    when 'leave-muc', 'part'
      muc,nick = param.split(':',2)
      lambda do |client|
        puts "leaving MUC: #{muc}"
        client.entity(muc).muc.part(nick)
      end

    when 'invite-to-muc'
      muc,nick = param.split(':',2)
      lambda do |client|
        puts "inviting #{nick} to #{muc}"
        client.entity(muc).muc.invite(nick)
      end

    when 'say', 'tell', 'message', 'msg'
      dst,msg = param.split(':',2)
      lambda do |client|
        puts "speaking to: #{dst}"
        client.entity(dst).say(msg)
      end

    when 'gsay', 'gtell', 'gmsg'
      dst,msg = param.split(':',2)
      lambda do |client|
        puts "speaking in MUC: #{dst}"
        client.entity(dst).muc.say(msg)
      end

    when 'motd','subject'
      dst,msg = param.split(':',2)
      lambda do |client|
        puts "setting motd of: #{dst}"
        client.entity(dst).muc.motd(msg)
      end

    when 'nickname','nick'
      dst,name = param.split(':',2)
      lambda do |client|
        puts "using nickname: #{dst}"
        client.entity(dst).muc.change_nick(name)
      end

    when 'kick'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "kicking #{user}"
        client.entity(dst).muc.kick(user)
      end

    when 'ban'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "banning #{user}"
        client.entity(dst).muc.ban(user)
      end

    when 'unban'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "unbanning #{user}"
        client.entity(dst).muc.unban(user)
      end

    when 'moderator'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "moddeerating #{user}"
        client.entity(dst).muc.moderator(user)
      end

    when 'unmoderator'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "unmoderating #{user}"
        client.entity(dst).muc.unmoderator(user)
      end

    when 'admin'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "admin #{user}"
        client.entity(dst).muc.admin(user)
      end

    when 'unadmin'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "unadmin #{user}"
        client.entity(dst).muc.unadmin(user)
      end

    when 'owner'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "new owner #{user}"
        client.entity(dst).muc.owner(user)
      end

    when 'unowner'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "remove owner #{user}"
        client.entity(dst).muc.unowner(user)
      end

    when 'voice'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "voicing #{user}"
        client.entity(dst).muc.voice(user)
      end

    when 'unvoice'
      dst,user = param.split(':',2)
      lambda do |client|
        puts "unvoicing #{user}"
        client.entity(dst).muc.unvoice(user)
      end
     
    when 'disco-infos','infos'
      dst,node = param.split(':',2)
      lambda do |client|
        puts "discovering infos for: #{dst} (node:#{node})"
        disco = client.entity(dst).discover_infos(node)

        puts "=== Identities ==="
        disco.bit!(:discoinfos).identities.each do |i|
          puts "#{i.category}/#{i.type}: #{i.name || "_"}"
        end
        puts "=== Features ==="
        disco.bit!(:discoinfos).features.each do |f|
          puts "#{f.var}"
        end
      end
      
    when 'disco-items','items'
      dst,node = param.split(':',2)
      lambda do |client|
        puts "discovering items for: #{dst} (node:#{node})"
        disco = client.entity(dst).discover_items(node)

        puts "=== Items ==="
        disco.bit!(:discoitems).items.each do |i|
          puts "#{i.entity} (#{i.node}) -- #{i.name || i.entity}"
        end
      end
    else
      raise CommandParseError, "doesn't know such command: #{cmd}"
    end
  end
end

commands = ARGV[2 .. -1]

module RosterClient
  include EM::Xmpp::Helpers
  attr_reader :queue

  def ready
    @show_xml = false
    puts "***** #{@jid} ready"
    user_data.each{|c| handle_command c}
    EM.open_keyboard Kb, self

    # Writes a stack-trace on error
    on_exception(:anything) do |ctx|
      raise ctx['error']
    end


    # Signal presence subscriptions
    on_presence do |ctx|
      pre = ctx.bit!(:presence)
      if pre.subscription_request?
        puts "=== Presence subscription request from: #{pre.from.bare}"
        ctx.done!
      end
      ctx
    end

    # Signal people arriving and leaving
    on_presence do |ctx|
      pre = ctx.bit!(:presence)
      puts "=== Presence #{pre.from}: #{pre.type}"
      ctx.done!
    end

    # Acknowledge roster change 
    on_iq do |ctx|
      roster = ctx.bit(:roster)
      if roster
        if roster.type == 'set'
          puts "=== Roster change ==="
          roster.items.each do |item|
            puts "#{item.name||item.jid} -- #{item.jid} (#{item.type})"
          end
          send_stanza roster.reply
          ctx.done!
        end
      end
      ctx
    end

    # Prints Pubsub event
    on_message do |ctx|
      event = ctx.bit(:pubsubevent)
      delay = ctx.bit(:delay)
      stamp = delay.stamp if delay
      if event
        puts "=== PubSub event #{event.service} #{stamp} ==="
        if event.items_node #oddly enough, retractions fall in items_node
          items       = event.items
          retractions = event.retractions

          if items.any? or retractions.any?
            items.each do |i|
              puts "+item> #{i.node} #{i.item_id} (by #{i.publisher || 'N/A'})"
              puts i.payload
            end

            event.retractions.each do |r|
              puts "-item> #{r.node} #{r.item_id}"
            end
          else
            puts "empty items list for #{event.node_id}"
          end
        end


        if event.purge
          puts "node purged #{event.purge.node}"
        end

        if event.deletion
          del = event.deletion
          puts "node destroyed #{del.node}"
          puts "  now redirects to #{del.redirect}" if del.redirect
        end

        if event.configuration
          cfg = event.configuration
          puts "new node configuration for #{cfg.node}"
          Command.print_dataform(ctx)
        end

        ctx.done!
      end

      event = ctx.bit(:pubsub)
      if event
        puts "=== PubSub #{event.service} ==="
        event.subscriptions.each do |sub|
          puts "subscription of #{sub.jid} (#{sub.sub_id}) status is now #{sub.subscription} for #{sub.node}"
          puts "expires on #{sub.expiry}" if sub.expiry
        end
        ctx.done!
      end
      ctx
    end
  end

  def stanza_end(stanza)
    puts stanza if @show_xml
    super
  end

  def handle_command(str)
    begin
      Command.for(str).call self
    rescue CommandParseError
      puts "could not parse #{str}"
    end
  end

  def quit
    close_xml_stream
    close_connection
  end

  def set(key,val)
    case key
    when '+xml'
      @show_xml = true
    when '-xml'
      @show_xml = false
    when '+debug'
      @show_xml = false
      $DEBUG = true
    when '-debug'
      $DEBUG = false
    end
  end

  def unbind
    EM.stop
  end
end

class Kb < EM::Connection
  include EM::Protocols::LineText2
  def initialize(client)
    @client = client
  end
  def receive_line line
    Fiber.new { @client.handle_command line unless line.empty?}.resume
  end
end

EM.run do
  EM::Xmpp::Connection.start(jid, pass, RosterClient, {:data => commands})
  puts "***** connecting as #{jid}"
end
